<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mouse to Cheese Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            overflow-y: auto;
        }

        .main-wrapper {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .game-container {
            text-align: center;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .instructions {
            color: #ecf0f1;
            margin-bottom: 15px;
            font-size: 14px;
        }

        #gameCanvas {
            border: 4px solid #fff;
            border-radius: 10px;
            background: #1a1a2e;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            color: #fff;
            font-size: 18px;
        }

        .time-warning {
            animation: timePulse 0.5s ease-in-out infinite;
            color: #e74c3c !important;
            font-weight: bold;
        }

        @keyframes timePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        #message {
            margin-top: 15px;
            font-size: 24px;
            color: #2ecc71;
            font-weight: bold;
            min-height: 30px;
        }

        #restartBtn {
            margin-top: 15px;
            padding: 12px 30px;
            font-size: 16px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }

        #restartBtn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        .about-section {
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            width: 180px;
            flex-shrink: 0;
        }

        .about-section h2 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .creators {
            color: #ecf0f1;
            font-size: 13px;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .about-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .about-btn {
            padding: 10px 15px;
            font-size: 12px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
        }

        .about-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .tutorial-btn {
            background: #3498db;
            color: white;
        }

        .ai-btn {
            background: #D97757;
            color: white;
        }

        .claude-logo {
            width: 20px;
            height: 20px;
        }

        /* Dialog styles */
        .dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .dialog-overlay.active {
            display: flex;
        }

        .dialog {
            background: #1a1a2e;
            border-radius: 20px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            border: 2px solid #3498db;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: dialogPop 0.3s ease;
        }

        @keyframes dialogPop {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .dialog h2 {
            color: #fff;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dialog-content {
            color: #ecf0f1;
            font-size: 15px;
            line-height: 1.6;
        }

        .dialog-content p {
            margin-bottom: 12px;
        }

        .key {
            display: inline-block;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 4px 10px;
            font-family: monospace;
            font-size: 13px;
            margin: 2px;
        }

        .close-btn {
            margin-top: 20px;
            padding: 10px 30px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
        }

        .close-btn:hover {
            background: #2980b9;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .stat-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #D97757;
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }

        .ai-note {
            font-size: 12px;
            color: #888;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        /* Touch Controls */
        .touch-controls {
            display: none;
            margin-top: 15px;
            touch-action: none;
        }

        .dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
            justify-content: center;
        }

        .dpad-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .dpad-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }

        .dpad-btn.up { grid-column: 2; grid-row: 1; }
        .dpad-btn.left { grid-column: 1; grid-row: 2; }
        .dpad-btn.center { grid-column: 2; grid-row: 2; background: transparent; }
        .dpad-btn.right { grid-column: 3; grid-row: 2; }
        .dpad-btn.down { grid-column: 2; grid-row: 3; }

        .mobile-space-btn {
            margin-top: 10px;
            padding: 15px 40px;
            font-size: 16px;
            background: #2ecc71;
            color: white;
            border: none;
            border-radius: 25px;
            touch-action: none;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                min-height: 100dvh;
            }

            .main-wrapper {
                flex-direction: column;
                gap: 15px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 5px;
            }

            .instructions {
                font-size: 12px;
                margin-bottom: 10px;
            }

            #gameCanvas {
                max-width: 100%;
                height: auto;
                border-width: 2px;
            }

            .stats {
                gap: 15px;
                font-size: 14px;
                margin-top: 10px;
            }

            #message {
                font-size: 16px;
                margin-top: 10px;
                min-height: 24px;
            }

            #restartBtn {
                padding: 10px 20px;
                font-size: 14px;
                margin-top: 10px;
            }

            .touch-controls {
                display: block;
            }

            .about-section {
                width: 100%;
                max-width: 300px;
                padding: 15px;
                margin-top: 10px;
            }

            .about-buttons {
                flex-direction: row;
                justify-content: center;
            }

            .about-btn {
                width: auto;
                padding: 8px 15px;
            }

            .dialog {
                padding: 20px;
                max-width: 90%;
            }

            .stat-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .stat-item {
                padding: 10px;
            }

            .stat-value {
                font-size: 20px;
            }
        }

        @media (max-width: 400px) {
            h1 {
                font-size: 16px;
            }

            .dpad-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="game-container">
            <h1>Guide the Mouse to the Cheese!</h1>
            <p class="instructions">Use Arrow Keys or WASD to move</p>
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            <div class="stats">
                <span>Level: <span id="level">1</span></span>
                <span>Score: <span id="score">0</span></span>
                <span>Time: <span id="time">0</span>s</span>
            </div>
            <div id="message"></div>
            <button id="restartBtn">Restart Game</button>

            <!-- Mobile Touch Controls -->
            <div class="touch-controls" id="touchControls">
                <div class="dpad">
                    <button class="dpad-btn up" data-dir="up">▲</button>
                    <button class="dpad-btn left" data-dir="left">◀</button>
                    <div class="dpad-btn center"></div>
                    <button class="dpad-btn right" data-dir="right">▶</button>
                    <button class="dpad-btn down" data-dir="down">▼</button>
                </div>
                <button class="mobile-space-btn" id="mobileSpaceBtn">NEXT LEVEL</button>
            </div>
        </div>

        <div class="about-section">
            <h2>About</h2>
            <p class="creators">Created by<br><strong>Farhan Khan</strong><br>&<br><strong>Zoella Khan</strong></p>
            <div class="about-buttons">
                <button class="about-btn tutorial-btn" id="tutorialBtn">
                    <span>?</span> How to Play
                </button>
                <button class="about-btn ai-btn" id="aiStatsBtn">
                    <svg class="claude-logo" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M4.709 15.955l4.72-2.647.08-.23-.08-.128H8.2l-.696-.463-.063-.395.063-.131h2.378l.158-.197.715-2.058.142-.13h1.672l.142.13.714 2.058.159.197h2.378l.063.131-.063.395-.696.463H13.57l-.08.129.08.229 4.72 2.647.048.35-.238.286-3.428-.878-.16.063-.238 1.334-.127.128H9.854l-.127-.128-.239-1.334-.159-.063-3.428.878-.238-.286.048-.35zm6.327-7.391l-.476 1.373h1.88l-.476-1.373-.159-.298h-.61l-.159.298z"/>
                    </svg>
                    Built with AI
                </button>
            </div>
        </div>
    </div>

    <!-- Tutorial Dialog -->
    <div class="dialog-overlay" id="tutorialDialog">
        <div class="dialog">
            <h2><span>?</span> How to Play</h2>
            <div class="dialog-content">
                <p><strong>Goal:</strong> Guide your mouse to the cheese!</p>
                <p><strong>Controls:</strong></p>
                <p>
                    <span class="key">Arrow Up</span> or <span class="key">W</span> - Move up<br>
                    <span class="key">Arrow Down</span> or <span class="key">S</span> - Move down<br>
                    <span class="key">Arrow Left</span> or <span class="key">A</span> - Move left<br>
                    <span class="key">Arrow Right</span> or <span class="key">D</span> - Move right
                </p>
                <p><strong>Watch out!</strong> Avoid the electric zappers - they move up and down!</p>
                <p>Press <span class="key">SPACE</span> after completing a level to continue.</p>
            </div>
            <button class="close-btn" id="closeTutorial">Got it!</button>
        </div>
    </div>

    <!-- AI Stats Dialog -->
    <div class="dialog-overlay" id="aiStatsDialog">
        <div class="dialog">
            <h2>
                <svg class="claude-logo" viewBox="0 0 24 24" fill="#D97757" width="24" height="24">
                    <path d="M4.709 15.955l4.72-2.647.08-.23-.08-.128H8.2l-.696-.463-.063-.395.063-.131h2.378l.158-.197.715-2.058.142-.13h1.672l.142.13.714 2.058.159.197h2.378l.063.131-.063.395-.696.463H13.57l-.08.129.08.229 4.72 2.647.048.35-.238.286-3.428-.878-.16.063-.238 1.334-.127.128H9.854l-.127-.128-.239-1.334-.159-.063-3.428.878-.238-.286.048-.35zm6.327-7.391l-.476 1.373h1.88l-.476-1.373-.159-.298h-.61l-.159.298z"/>
                </svg>
                Built with Claude AI
            </h2>
            <div class="dialog-content">
                <p>This game was created through a conversation with Claude (Opus 4.5), Anthropic's AI assistant.</p>
                <div class="stat-grid">
                    <div class="stat-item">
                        <div class="stat-value">10</div>
                        <div class="stat-label">Prompts Exchanged</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">~25</div>
                        <div class="stat-label">Minutes to Create</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">700+</div>
                        <div class="stat-label">Lines of Code</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">4</div>
                        <div class="stat-label">Obstacle Designs Tried</div>
                    </div>
                </div>
                <p><strong>Features built:</strong> Mouse & cheese graphics, grid background, moving electric zappers, collision detection, level progression, score system, hit effects, confetti celebrations, and GitHub Pages deployment.</p>
                <p class="ai-note">Made with Claude Code - AI pair programming in the terminal.</p>
            </div>
            <button class="close-btn" id="closeAiStats">Cool!</button>
        </div>
    </div>

    <!-- Restart Confirmation Dialog -->
    <div class="dialog-overlay" id="restartDialog">
        <div class="dialog" style="max-width: 350px;">
            <h2>Restart Game?</h2>
            <div class="dialog-content">
                <p>Are you sure you want to restart? Your current progress will be lost.</p>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button class="close-btn" id="confirmRestart" style="background: #e74c3c;">Yes, Restart</button>
                <button class="close-btn" id="cancelRestart" style="background: #7f8c8d;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageEl = document.getElementById('message');
        const levelEl = document.getElementById('level');
        const scoreEl = document.getElementById('score');
        const timeEl = document.getElementById('time');
        const restartBtn = document.getElementById('restartBtn');

        // ============== GAME CONFIG ==============
        const CONFIG = {
            // Timing
            timeLimit: 30,
            hitFlashDecay: 0.03,
            timeUpFlashDecay: 0.03,

            // Mouse settings
            mouse: {
                size: 30,
                speed: 5
            },

            // Cheese settings
            cheese: {
                size: 35,
                shrinkRate: 0.15,
                minSize: 5
            },

            // Obstacle settings
            obstacles: {
                maxCount: 8,
                minSize: 40,
                maxSize: 70,
                minSpeed: 0.5,
                maxSpeed: 1.5,
                minGap: 80,
                spawnMarginX: 120,
                spawnMarginRight: 280
            },

            // Visual effects
            effects: {
                confettiCount: 100,
                sparkCount: 20,
                colors: ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8']
            },

            // Spawn positions for mouse/cheese
            spawnPositions: [
                { x: 50, y: 50 },
                { x: 550, y: 50 },
                { x: 50, y: 350 },
                { x: 550, y: 350 },
                { x: 50, y: 200 },
                { x: 550, y: 200 },
                { x: 300, y: 50 },
                { x: 300, y: 350 }
            ]
        };

        // ============== GAME STATE ==============
        const state = {
            level: 1,
            score: 0,
            levelStartTime: Date.now(),
            gameWon: false,
            isHit: false,
            isEating: false,
            hitFlash: 0,
            timeUpFlash: 0,
            nibbleFrame: 0,
            celebrationActive: false,
            keys: {},
            confetti: [],
            electricSparks: [],
            obstacles: []
        };

        // ============== ENTITIES ==============
        const mouse = {
            x: 50,
            y: 200,
            size: CONFIG.mouse.size,
            speed: CONFIG.mouse.speed
        };

        const cheese = {
            x: 500,
            y: 200,
            size: CONFIG.cheese.size,
            currentSize: CONFIG.cheese.size
        };

        // ============== SAVE/LOAD ==============
        function saveProgress() {
            localStorage.setItem('mouseCheeseGame', JSON.stringify({
                level: level,
                score: score
            }));
        }

        function loadProgress() {
            const saved = localStorage.getItem('mouseCheeseGame');
            if (saved) {
                const data = JSON.parse(saved);
                state.level = level = data.level || 1;
                state.score = score = data.score || 0;
                levelEl.textContent = level;
                scoreEl.textContent = score;
            }
        }

        function clearProgress() {
            localStorage.removeItem('mouseCheeseGame');
        }

        // Legacy references for compatibility
        let obstacles = state.obstacles;
        let confetti = state.confetti;
        let keys = state.keys;
        let electricSparks = state.electricSparks;
        let level = state.level;
        let score = state.score;
        let levelStartTime = state.levelStartTime;
        let gameWon = state.gameWon;
        let isHit = state.isHit;
        let isEating = state.isEating;
        let hitFlash = state.hitFlash;
        let timeUpFlash = state.timeUpFlash;
        let nibbleFrame = state.nibbleFrame;
        let celebrationActive = state.celebrationActive;

        function drawMouse(x, y, size) {
            // Body
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.ellipse(x, y, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(x + size * 0.4, y, size * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(x + size * 0.5, y - size * 0.35, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.3, y - size * 0.4, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x + size * 0.55, y - size * 0.1, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(x + size * 0.7, y + size * 0.05, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y);
            ctx.quadraticCurveTo(x - size * 0.8, y - size * 0.3, x - size * 0.9, y + size * 0.2);
            ctx.stroke();

            // Whiskers
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = -1; i <= 1; i++) {
                ctx.beginPath();
                ctx.moveTo(x + size * 0.6, y + size * 0.05);
                ctx.lineTo(x + size * 0.9, y + i * size * 0.15);
                ctx.stroke();
            }
        }

        function drawEatingMouse(x, y, size, frame) {
            // Bobbing animation
            const bob = Math.sin(frame) * 2;
            const mouthOpen = Math.sin(frame * 2) > 0;

            // Body
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.ellipse(x, y + bob, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head (moves forward when nibbling)
            const headOffset = mouthOpen ? 3 : 0;
            ctx.beginPath();
            ctx.arc(x + size * 0.4 + headOffset, y + bob, size * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(x + size * 0.5 + headOffset, y - size * 0.35 + bob, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.3 + headOffset, y - size * 0.4 + bob, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Happy closed eyes (arcs)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + size * 0.55 + headOffset, y - size * 0.1 + bob, size * 0.06, 0, Math.PI);
            ctx.stroke();

            // Nose
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(x + size * 0.7 + headOffset, y + size * 0.05 + bob, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (open/closed for chewing)
            if (mouthOpen) {
                ctx.fillStyle = '#FF6B6B';
                ctx.beginPath();
                ctx.arc(x + size * 0.65 + headOffset, y + size * 0.15 + bob, size * 0.1, 0, Math.PI);
                ctx.fill();
            }

            // Tail (wagging happily)
            const tailWag = Math.sin(frame * 3) * 0.2;
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y + bob);
            ctx.quadraticCurveTo(x - size * 0.8, y - size * 0.3 + Math.sin(frame * 3) * 10, x - size * 0.9, y + size * 0.2 + bob);
            ctx.stroke();

            // Whiskers (twitching)
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = -1; i <= 1; i++) {
                const twitch = Math.sin(frame * 4 + i) * 3;
                ctx.beginPath();
                ctx.moveTo(x + size * 0.6 + headOffset, y + size * 0.05 + bob);
                ctx.lineTo(x + size * 0.9 + headOffset, y + i * size * 0.15 + bob + twitch);
                ctx.stroke();
            }

            // Cheese crumbs flying
            ctx.fillStyle = '#FFD700';
            for (let i = 0; i < 3; i++) {
                const crumbX = x + size * 0.8 + Math.sin(frame + i * 2) * 15;
                const crumbY = y + Math.cos(frame * 2 + i) * 10 - 5;
                const crumbSize = 2 + Math.random();
                ctx.beginPath();
                ctx.arc(crumbX, crumbY + bob, crumbSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawCheese(x, y, size) {
            // Main cheese body
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y + size * 0.3);
            ctx.lineTo(x, y - size * 0.4);
            ctx.lineTo(x + size * 0.5, y + size * 0.3);
            ctx.closePath();
            ctx.fill();

            // Darker side
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(x + size * 0.5, y + size * 0.3);
            ctx.lineTo(x, y - size * 0.4);
            ctx.lineTo(x + size * 0.2, y - size * 0.3);
            ctx.lineTo(x + size * 0.5, y + size * 0.1);
            ctx.closePath();
            ctx.fill();

            // Holes
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.arc(x - size * 0.15, y, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.1, y + size * 0.15, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - size * 0.05, y - size * 0.15, size * 0.06, 0, Math.PI * 2);
            ctx.fill();
        }

        let zapperPhase = 0;

        function drawObstacle(obs) {
            const x = obs.x;
            const y = obs.y;
            const w = obs.width;
            const h = obs.height;
            const cx = x + w / 2;
            const cy = y + h / 2;

            // Outer glow
            const glowIntensity = 0.3 + Math.sin(zapperPhase + obs.x) * 0.2;
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 15;

            // Metal frame
            ctx.fillStyle = '#333';
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 6);
            ctx.fill();
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Inner electric area
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.roundRect(x + 4, y + 4, w - 8, h - 8, 4);
            ctx.fill();

            // Electric grid lines (vertical)
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 + glowIntensity})`;
            ctx.lineWidth = 2;
            for (let i = 0.25; i < 1; i += 0.25) {
                ctx.beginPath();
                ctx.moveTo(x + w * i, y + 6);
                ctx.lineTo(x + w * i, y + h - 6);
                ctx.stroke();
            }

            // Electric grid lines (horizontal)
            for (let i = 0.25; i < 1; i += 0.25) {
                ctx.beginPath();
                ctx.moveTo(x + 6, y + h * i);
                ctx.lineTo(x + w - 6, y + h * i);
                ctx.stroke();
            }

            // Spark effects
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            const numSparks = 3;
            for (let i = 0; i < numSparks; i++) {
                const sparkX = x + 10 + Math.sin(zapperPhase * 3 + i * 2 + obs.y) * (w - 20) / 2 + (w - 20) / 2;
                const sparkY = y + 10 + Math.cos(zapperPhase * 2 + i * 3 + obs.x) * (h - 20) / 2 + (h - 20) / 2;

                ctx.beginPath();
                ctx.moveTo(sparkX - 4, sparkY);
                ctx.lineTo(sparkX + 4, sparkY);
                ctx.moveTo(sparkX, sparkY - 4);
                ctx.lineTo(sparkX, sparkY + 4);
                ctx.stroke();
            }

            // Corner bolts
            ctx.fillStyle = '#666';
            const boltSize = 4;
            ctx.beginPath();
            ctx.arc(x + 6, y + 6, boltSize, 0, Math.PI * 2);
            ctx.arc(x + w - 6, y + 6, boltSize, 0, Math.PI * 2);
            ctx.arc(x + 6, y + h - 6, boltSize, 0, Math.PI * 2);
            ctx.arc(x + w - 6, y + h - 6, boltSize, 0, Math.PI * 2);
            ctx.fill();

            // Danger symbol (lightning bolt)
            ctx.fillStyle = `rgba(255, 255, 0, ${0.7 + glowIntensity})`;
            ctx.beginPath();
            ctx.moveTo(cx + 2, cy - h * 0.25);
            ctx.lineTo(cx - 5, cy + 2);
            ctx.lineTo(cx, cy);
            ctx.lineTo(cx - 2, cy + h * 0.25);
            ctx.lineTo(cx + 5, cy - 2);
            ctx.lineTo(cx, cy);
            ctx.closePath();
            ctx.fill();
        }

        function checkObstacleOverlap(obs1, obs2, minGap) {
            return obs1.x - minGap < obs2.x + obs2.width &&
                   obs1.x + obs1.width + minGap > obs2.x &&
                   obs1.y - minGap < obs2.y + obs2.height &&
                   obs1.y + obs1.height + minGap > obs2.y;
        }

        function generateObstacles() {
            obstacles = [];
            state.obstacles = obstacles;
            const cfg = CONFIG.obstacles;
            const numObstacles = Math.min(state.level + 1, cfg.maxCount);

            for (let i = 0; i < numObstacles; i++) {
                let obs;
                let attempts = 0;
                let valid = false;

                do {
                    const moveHorizontal = Math.random() < 0.5;
                    const speed = (cfg.minSpeed + Math.random() * (cfg.maxSpeed - cfg.minSpeed)) * (Math.random() < 0.5 ? 1 : -1);
                    const sizeRange = cfg.maxSize - cfg.minSize;
                    obs = {
                        x: cfg.spawnMarginX + Math.random() * (canvas.width - cfg.spawnMarginRight),
                        y: Math.random() * (canvas.height - cfg.minSize),
                        width: cfg.minSize + Math.random() * sizeRange * 0.5,
                        height: cfg.minSize + Math.random() * sizeRange * 0.5,
                        vx: moveHorizontal ? speed : 0,
                        vy: moveHorizontal ? 0 : speed
                    };

                    valid = !checkCollision(mouse, obs) && !checkCheeseCollision(obs);

                    // Check distance from other obstacles
                    for (const existing of obstacles) {
                        if (checkObstacleOverlap(obs, existing, cfg.minGap)) {
                            valid = false;
                            break;
                        }
                    }

                    attempts++;
                } while (attempts < 100 && !valid);

                if (valid) obstacles.push(obs);
            }
        }

        function updateObstacles() {
            for (const obs of obstacles) {
                // Update position
                obs.x += obs.vx;
                obs.y += obs.vy;

                // Bounce off left and right edges
                if (obs.x <= 0) {
                    obs.x = 0;
                    obs.vx = Math.abs(obs.vx);
                } else if (obs.x + obs.width >= canvas.width) {
                    obs.x = canvas.width - obs.width;
                    obs.vx = -Math.abs(obs.vx);
                }

                // Bounce off top and bottom edges
                if (obs.y <= 0) {
                    obs.y = 0;
                    obs.vy = Math.abs(obs.vy);
                } else if (obs.y + obs.height >= canvas.height) {
                    obs.y = canvas.height - obs.height;
                    obs.vy = -Math.abs(obs.vy);
                }

                // Check if obstacle hits mouse
                if (!isHit && checkCollision(mouse, obs)) {
                    triggerHit();
                }
            }
        }

        function triggerHit() {
            state.isHit = isHit = true;
            state.hitFlash = hitFlash = 1;
            messageEl.textContent = 'ZZZAP! Restarting level...';
            messageEl.style.color = '#00FFFF';

            // Create electric sparks
            electricSparks = [];
            state.electricSparks = electricSparks;
            for (let i = 0; i < CONFIG.effects.sparkCount; i++) {
                electricSparks.push({
                    x: mouse.x,
                    y: mouse.y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1
                });
            }

            setTimeout(() => {
                restartLevel();
            }, 1000);
        }

        function restartLevel() {
            positionMouseAndCheese();
            generateObstacles();
            isHit = false;
            hitFlash = 0;
            timeUpFlash = 0;
            electricSparks = [];
            messageEl.textContent = '';
            timeEl.parentElement.classList.remove('time-warning');
        }

        function checkCollision(m, obs) {
            return m.x + m.size * 0.6 > obs.x &&
                   m.x - m.size * 0.6 < obs.x + obs.width &&
                   m.y + m.size * 0.4 > obs.y &&
                   m.y - m.size * 0.4 < obs.y + obs.height;
        }

        function checkCheeseCollision(obs) {
            return cheese.x + cheese.size * 0.5 > obs.x &&
                   cheese.x - cheese.size * 0.5 < obs.x + obs.width &&
                   cheese.y + cheese.size * 0.4 > obs.y &&
                   cheese.y - cheese.size * 0.4 < obs.y + obs.height;
        }

        function checkWin() {
            const dx = mouse.x - cheese.x;
            const dy = mouse.y - cheese.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (mouse.size + cheese.size) * 0.4;
        }

        function spawnConfetti() {
            confetti = [];
            state.confetti = confetti;
            const colors = CONFIG.effects.colors;
            for (let i = 0; i < CONFIG.effects.confettiCount; i++) {
                confetti.push({
                    x: Math.random() * canvas.width,
                    y: -20 - Math.random() * 200,
                    vx: (Math.random() - 0.5) * 4,
                    vy: 2 + Math.random() * 3,
                    size: 5 + Math.random() * 8,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    shape: Math.random() > 0.5 ? 'rect' : 'circle'
                });
            }
            state.celebrationActive = true;
            celebrationActive = true;
        }

        function updateConfetti() {
            for (const c of confetti) {
                c.x += c.vx;
                c.y += c.vy;
                c.rotation += c.rotationSpeed;
                c.vy += 0.05; // gravity
                c.vx *= 0.99; // air resistance
            }
            // Remove confetti that fell off screen
            confetti = confetti.filter(c => c.y < canvas.height + 50);
            if (confetti.length === 0) {
                celebrationActive = false;
            }
        }

        function drawConfetti() {
            for (const c of confetti) {
                ctx.save();
                ctx.translate(c.x, c.y);
                ctx.rotate(c.rotation);
                ctx.fillStyle = c.color;

                if (c.shape === 'rect') {
                    ctx.fillRect(-c.size / 2, -c.size / 4, c.size, c.size / 2);
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, c.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        function positionMouseAndCheese() {
            const positions = CONFIG.spawnPositions;

            // Pick random position for mouse
            const mouseIdx = Math.floor(Math.random() * positions.length);
            const mousePos = positions[mouseIdx];

            // Find the farthest position for cheese
            let maxDist = 0;
            let cheesePos = positions[0];
            for (const pos of positions) {
                const dist = Math.sqrt(
                    Math.pow(pos.x - mousePos.x, 2) +
                    Math.pow(pos.y - mousePos.y, 2)
                );
                if (dist > maxDist) {
                    maxDist = dist;
                    cheesePos = pos;
                }
            }

            // Add some randomness to cheese position
            cheesePos = {
                x: cheesePos.x + (Math.random() - 0.5) * 60,
                y: cheesePos.y + (Math.random() - 0.5) * 60
            };

            // Keep cheese within bounds
            cheesePos.x = Math.max(40, Math.min(canvas.width - 40, cheesePos.x));
            cheesePos.y = Math.max(40, Math.min(canvas.height - 40, cheesePos.y));

            mouse.x = mousePos.x;
            mouse.y = mousePos.y;
            cheese.x = cheesePos.x;
            cheese.y = cheesePos.y;
            cheese.currentSize = cheese.size;
        }

        // Helper to reset level state
        function resetLevelState() {
            state.gameWon = gameWon = false;
            state.isEating = isEating = false;
            state.isHit = isHit = false;
            state.hitFlash = hitFlash = 0;
            state.timeUpFlash = timeUpFlash = 0;
            state.nibbleFrame = nibbleFrame = 0;
            state.celebrationActive = celebrationActive = false;
            state.confetti = confetti = [];
            state.electricSparks = electricSparks = [];
            state.levelStartTime = levelStartTime = Date.now();
            messageEl.textContent = '';
            timeEl.parentElement.classList.remove('time-warning');
        }

        function nextLevel() {
            state.level = ++level;
            levelEl.textContent = state.level;
            state.score = score += 100 + state.level * 10;
            scoreEl.textContent = state.score;

            positionMouseAndCheese();
            generateObstacles();
            resetLevelState();
            saveProgress();
        }

        function resetGame() {
            state.level = level = 1;
            state.score = score = 0;
            mouse.size = CONFIG.mouse.size;
            mouse.speed = CONFIG.mouse.speed;
            cheese.size = CONFIG.cheese.size;
            cheese.currentSize = CONFIG.cheese.size;

            positionMouseAndCheese();
            generateObstacles();
            resetLevelState();
            clearProgress();

            levelEl.textContent = state.level;
            scoreEl.textContent = state.score;
            timeEl.parentElement.classList.remove('time-warning');
        }

        function update() {
            // Update zapper animation
            zapperPhase += 0.1;

            // Decay hit flash and update sparks
            if (hitFlash > 0) {
                state.hitFlash = hitFlash -= CONFIG.hitFlashDecay;

                // Update electric sparks
                for (const spark of electricSparks) {
                    spark.x += spark.vx;
                    spark.y += spark.vy;
                    spark.life -= 0.03;
                    spark.vx *= 0.95;
                    spark.vy *= 0.95;
                }
            }

            // Decay time up flash
            if (timeUpFlash > 0) {
                state.timeUpFlash = timeUpFlash -= CONFIG.timeUpFlashDecay;
            }

            // Update confetti
            if (celebrationActive) {
                updateConfetti();
            }

            // Update eating animation
            if (isEating && !gameWon) {
                state.nibbleFrame = nibbleFrame += 0.3;
                // Slowly shrink the cheese
                if (cheese.currentSize > CONFIG.cheese.minSize) {
                    cheese.currentSize -= CONFIG.cheese.shrinkRate;
                }
                // Keep mouse at cheese position
                mouse.x = cheese.x - 20;
                mouse.y = cheese.y;
            }

            if (!gameWon && !isHit && !isEating) {
                updateObstacles();
            }

            if (gameWon || isHit || isEating) return;

            let newX = mouse.x;
            let newY = mouse.y;

            if (keys['ArrowUp'] || keys['KeyW']) newY -= mouse.speed;
            if (keys['ArrowDown'] || keys['KeyS']) newY += mouse.speed;
            if (keys['ArrowLeft'] || keys['KeyA']) newX -= mouse.speed;
            if (keys['ArrowRight'] || keys['KeyD']) newX += mouse.speed;

            // Boundary check
            newX = Math.max(mouse.size, Math.min(canvas.width - mouse.size, newX));
            newY = Math.max(mouse.size * 0.5, Math.min(canvas.height - mouse.size * 0.5, newY));

            // Obstacle collision - zap on any contact
            mouse.x = newX;
            mouse.y = newY;

            for (const obs of obstacles) {
                if (checkCollision(mouse, obs)) {
                    triggerHit();
                    break;
                }
            }

            if (!isEating && checkWin()) {
                isEating = true;
                messageEl.textContent = 'Nom nom nom... Press SPACE for next level';
                messageEl.style.color = '#2ecc71';
                spawnConfetti();
            }

            // Update countdown timer
            const elapsed = Math.floor((Date.now() - levelStartTime) / 1000);
            const remaining = Math.max(0, CONFIG.timeLimit - elapsed);
            timeEl.textContent = remaining;

            // Animate when less than 10 seconds
            if (remaining <= 10 && remaining > 0) {
                timeEl.parentElement.classList.add('time-warning');
            } else {
                timeEl.parentElement.classList.remove('time-warning');
            }

            // Time's up!
            if (remaining === 0 && !isEating) {
                triggerTimeUp();
            }
        }

        function triggerTimeUp() {
            isHit = true;
            timeUpFlash = 1;
            messageEl.textContent = "Time's up! Restarting level...";
            messageEl.style.color = '#e74c3c';

            setTimeout(() => {
                restartLevel();
                levelStartTime = Date.now();
            }, 1000);
        }

        function draw() {
            // Clear canvas with grid background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            const gridSize = 40;
            ctx.strokeStyle = '#16213e';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw obstacles
            obstacles.forEach(drawObstacle);

            // Draw cheese (use currentSize for eating animation)
            if (cheese.currentSize > 5) {
                drawCheese(cheese.x, cheese.y, cheese.currentSize);
            }

            // Draw mouse (with nibble animation if eating)
            if (isEating) {
                drawEatingMouse(mouse.x, mouse.y, mouse.size, nibbleFrame);
            } else {
                drawMouse(mouse.x, mouse.y, mouse.size);
            }

            // Draw electric shock effect
            if (hitFlash > 0) {
                // Flickering cyan overlay
                const flicker = Math.random() > 0.5 ? 1 : 0.5;
                ctx.fillStyle = `rgba(0, 255, 255, ${hitFlash * 0.3 * flicker})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw lightning bolts from mouse
                ctx.strokeStyle = `rgba(0, 255, 255, ${hitFlash})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 20;

                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.3;
                    let x = mouse.x;
                    let y = mouse.y;
                    const length = 40 + (1 - hitFlash) * 60;

                    ctx.beginPath();
                    ctx.moveTo(x, y);

                    // Jagged lightning path
                    for (let j = 0; j < 5; j++) {
                        const stepLength = length / 5;
                        x += Math.cos(angle) * stepLength + (Math.random() - 0.5) * 15;
                        y += Math.sin(angle) * stepLength + (Math.random() - 0.5) * 15;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                // Draw skeleton effect on mouse (flashing bones)
                if (Math.random() > 0.3) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${hitFlash})`;
                    ctx.lineWidth = 2;
                    // Skeleton body
                    ctx.beginPath();
                    ctx.moveTo(mouse.x - 15, mouse.y);
                    ctx.lineTo(mouse.x + 15, mouse.y);
                    ctx.moveTo(mouse.x, mouse.y - 10);
                    ctx.lineTo(mouse.x, mouse.y + 10);
                    // Skeleton ribs
                    ctx.moveTo(mouse.x - 8, mouse.y - 5);
                    ctx.lineTo(mouse.x + 8, mouse.y - 5);
                    ctx.moveTo(mouse.x - 8, mouse.y + 5);
                    ctx.lineTo(mouse.x + 8, mouse.y + 5);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;

                // Draw electric sparks
                for (const spark of electricSparks) {
                    if (spark.life > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${spark.life})`;
                        ctx.beginPath();
                        ctx.arc(spark.x, spark.y, 3, 0, Math.PI * 2);
                        ctx.fill();

                        // Mini lightning from spark
                        ctx.strokeStyle = `rgba(0, 255, 255, ${spark.life})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(spark.x, spark.y);
                        ctx.lineTo(spark.x + (Math.random() - 0.5) * 10, spark.y + (Math.random() - 0.5) * 10);
                        ctx.stroke();
                    }
                }
            }

            // Draw time up flash effect
            if (timeUpFlash > 0) {
                const flicker = Math.random() > 0.5 ? 1 : 0.7;
                ctx.fillStyle = `rgba(231, 76, 60, ${timeUpFlash * 0.5 * flicker})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw clock icon in center
                ctx.strokeStyle = `rgba(255, 255, 255, ${timeUpFlash})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 40, 0, Math.PI * 2);
                ctx.stroke();

                // Clock hands
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, canvas.height / 2);
                ctx.lineTo(canvas.width / 2, canvas.height / 2 - 25);
                ctx.moveTo(canvas.width / 2, canvas.height / 2);
                ctx.lineTo(canvas.width / 2 + 20, canvas.height / 2);
                ctx.stroke();
            }

            // Draw confetti celebration
            if (celebrationActive) {
                drawConfetti();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && isEating) {
                // Go directly to next level
                nextLevel();
            }
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Restart confirmation
        const restartDialog = document.getElementById('restartDialog');
        const confirmRestart = document.getElementById('confirmRestart');
        const cancelRestart = document.getElementById('cancelRestart');

        restartBtn.addEventListener('click', () => {
            restartDialog.classList.add('active');
        });

        confirmRestart.addEventListener('click', () => {
            restartDialog.classList.remove('active');
            resetGame();
        });

        cancelRestart.addEventListener('click', () => {
            restartDialog.classList.remove('active');
        });

        restartDialog.addEventListener('click', (e) => {
            if (e.target === restartDialog) {
                restartDialog.classList.remove('active');
            }
        });

        // Mobile touch controls
        const dpadBtns = document.querySelectorAll('.dpad-btn[data-dir]');
        const mobileSpaceBtn = document.getElementById('mobileSpaceBtn');

        const dirToKey = {
            'up': 'ArrowUp',
            'down': 'ArrowDown',
            'left': 'ArrowLeft',
            'right': 'ArrowRight'
        };

        dpadBtns.forEach(btn => {
            const dir = btn.dataset.dir;
            const keyCode = dirToKey[dir];

            // Touch events
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[keyCode] = true;
                btn.style.background = 'rgba(255,255,255,0.4)';
            }, { passive: false });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[keyCode] = false;
                btn.style.background = 'rgba(255,255,255,0.2)';
            }, { passive: false });

            // Mouse events for testing on desktop
            btn.addEventListener('mousedown', () => {
                keys[keyCode] = true;
            });

            btn.addEventListener('mouseup', () => {
                keys[keyCode] = false;
            });

            btn.addEventListener('mouseleave', () => {
                keys[keyCode] = false;
            });
        });

        mobileSpaceBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isEating) {
                nextLevel();
            }
        }, { passive: false });

        mobileSpaceBtn.addEventListener('click', () => {
            if (isEating) {
                nextLevel();
            }
        });

        // Prevent scrolling on touch
        document.body.addEventListener('touchmove', (e) => {
            if (e.target.closest('.touch-controls')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Dialog handling
        const tutorialDialog = document.getElementById('tutorialDialog');
        const aiStatsDialog = document.getElementById('aiStatsDialog');
        const tutorialBtn = document.getElementById('tutorialBtn');
        const aiStatsBtn = document.getElementById('aiStatsBtn');
        const closeTutorial = document.getElementById('closeTutorial');
        const closeAiStats = document.getElementById('closeAiStats');

        tutorialBtn.addEventListener('click', () => {
            tutorialDialog.classList.add('active');
        });

        aiStatsBtn.addEventListener('click', () => {
            aiStatsDialog.classList.add('active');
        });

        closeTutorial.addEventListener('click', () => {
            tutorialDialog.classList.remove('active');
        });

        closeAiStats.addEventListener('click', () => {
            aiStatsDialog.classList.remove('active');
        });

        // Close dialogs on overlay click
        tutorialDialog.addEventListener('click', (e) => {
            if (e.target === tutorialDialog) {
                tutorialDialog.classList.remove('active');
            }
        });

        aiStatsDialog.addEventListener('click', (e) => {
            if (e.target === aiStatsDialog) {
                aiStatsDialog.classList.remove('active');
            }
        });

        // Close dialogs on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                tutorialDialog.classList.remove('active');
                aiStatsDialog.classList.remove('active');
            }
        });

        // Start game
        loadProgress();
        positionMouseAndCheese();
        generateObstacles();
        gameLoop();
    </script>
</body>
</html>
