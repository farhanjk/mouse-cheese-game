<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse to Cheese Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
        }

        .main-wrapper {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .game-container {
            text-align: center;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .instructions {
            color: #ecf0f1;
            margin-bottom: 15px;
            font-size: 14px;
        }

        #gameCanvas {
            border: 4px solid #fff;
            border-radius: 10px;
            background: #1a1a2e;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            color: #fff;
            font-size: 18px;
        }

        #message {
            margin-top: 15px;
            font-size: 24px;
            color: #2ecc71;
            font-weight: bold;
            min-height: 30px;
        }

        #restartBtn {
            margin-top: 15px;
            padding: 12px 30px;
            font-size: 16px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }

        #restartBtn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        .about-section {
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            width: 180px;
            flex-shrink: 0;
        }

        .about-section h2 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .creators {
            color: #ecf0f1;
            font-size: 13px;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .about-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .about-btn {
            padding: 10px 15px;
            font-size: 12px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
        }

        .about-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .tutorial-btn {
            background: #3498db;
            color: white;
        }

        .ai-btn {
            background: #D97757;
            color: white;
        }

        .claude-logo {
            width: 20px;
            height: 20px;
        }

        /* Dialog styles */
        .dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .dialog-overlay.active {
            display: flex;
        }

        .dialog {
            background: #1a1a2e;
            border-radius: 20px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            border: 2px solid #3498db;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: dialogPop 0.3s ease;
        }

        @keyframes dialogPop {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .dialog h2 {
            color: #fff;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dialog-content {
            color: #ecf0f1;
            font-size: 15px;
            line-height: 1.6;
        }

        .dialog-content p {
            margin-bottom: 12px;
        }

        .key {
            display: inline-block;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 4px 10px;
            font-family: monospace;
            font-size: 13px;
            margin: 2px;
        }

        .close-btn {
            margin-top: 20px;
            padding: 10px 30px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
        }

        .close-btn:hover {
            background: #2980b9;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .stat-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #D97757;
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }

        .ai-note {
            font-size: 12px;
            color: #888;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="game-container">
            <h1>Guide the Mouse to the Cheese!</h1>
            <p class="instructions">Use Arrow Keys or WASD to move</p>
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            <div class="stats">
                <span>Level: <span id="level">1</span></span>
                <span>Score: <span id="score">0</span></span>
                <span>Time: <span id="time">0</span>s</span>
            </div>
            <div id="message"></div>
            <button id="restartBtn">Restart Game</button>
        </div>

        <div class="about-section">
            <h2>About</h2>
            <p class="creators">Created by<br><strong>Farhan Khan</strong><br>&<br><strong>Zoella Khan</strong></p>
            <div class="about-buttons">
                <button class="about-btn tutorial-btn" id="tutorialBtn">
                    <span>?</span> How to Play
                </button>
                <button class="about-btn ai-btn" id="aiStatsBtn">
                    <svg class="claude-logo" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M4.709 15.955l4.72-2.647.08-.23-.08-.128H8.2l-.696-.463-.063-.395.063-.131h2.378l.158-.197.715-2.058.142-.13h1.672l.142.13.714 2.058.159.197h2.378l.063.131-.063.395-.696.463H13.57l-.08.129.08.229 4.72 2.647.048.35-.238.286-3.428-.878-.16.063-.238 1.334-.127.128H9.854l-.127-.128-.239-1.334-.159-.063-3.428.878-.238-.286.048-.35zm6.327-7.391l-.476 1.373h1.88l-.476-1.373-.159-.298h-.61l-.159.298z"/>
                    </svg>
                    Built with AI
                </button>
            </div>
        </div>
    </div>

    <!-- Tutorial Dialog -->
    <div class="dialog-overlay" id="tutorialDialog">
        <div class="dialog">
            <h2><span>?</span> How to Play</h2>
            <div class="dialog-content">
                <p><strong>Goal:</strong> Guide your mouse to the cheese!</p>
                <p><strong>Controls:</strong></p>
                <p>
                    <span class="key">Arrow Up</span> or <span class="key">W</span> - Move up<br>
                    <span class="key">Arrow Down</span> or <span class="key">S</span> - Move down<br>
                    <span class="key">Arrow Left</span> or <span class="key">A</span> - Move left<br>
                    <span class="key">Arrow Right</span> or <span class="key">D</span> - Move right
                </p>
                <p><strong>Watch out!</strong> Avoid the electric zappers - they move up and down!</p>
                <p>Press <span class="key">SPACE</span> after completing a level to continue.</p>
            </div>
            <button class="close-btn" id="closeTutorial">Got it!</button>
        </div>
    </div>

    <!-- AI Stats Dialog -->
    <div class="dialog-overlay" id="aiStatsDialog">
        <div class="dialog">
            <h2>
                <svg class="claude-logo" viewBox="0 0 24 24" fill="#D97757" width="24" height="24">
                    <path d="M4.709 15.955l4.72-2.647.08-.23-.08-.128H8.2l-.696-.463-.063-.395.063-.131h2.378l.158-.197.715-2.058.142-.13h1.672l.142.13.714 2.058.159.197h2.378l.063.131-.063.395-.696.463H13.57l-.08.129.08.229 4.72 2.647.048.35-.238.286-3.428-.878-.16.063-.238 1.334-.127.128H9.854l-.127-.128-.239-1.334-.159-.063-3.428.878-.238-.286.048-.35zm6.327-7.391l-.476 1.373h1.88l-.476-1.373-.159-.298h-.61l-.159.298z"/>
                </svg>
                Built with Claude AI
            </h2>
            <div class="dialog-content">
                <p>This game was created through a conversation with Claude (Opus 4.5), Anthropic's AI assistant.</p>
                <div class="stat-grid">
                    <div class="stat-item">
                        <div class="stat-value">10</div>
                        <div class="stat-label">Prompts Exchanged</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">~25</div>
                        <div class="stat-label">Minutes to Create</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">700+</div>
                        <div class="stat-label">Lines of Code</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">4</div>
                        <div class="stat-label">Obstacle Designs Tried</div>
                    </div>
                </div>
                <p><strong>Features built:</strong> Mouse & cheese graphics, grid background, moving electric zappers, collision detection, level progression, score system, hit effects, confetti celebrations, and GitHub Pages deployment.</p>
                <p class="ai-note">Made with Claude Code - AI pair programming in the terminal.</p>
            </div>
            <button class="close-btn" id="closeAiStats">Cool!</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageEl = document.getElementById('message');
        const levelEl = document.getElementById('level');
        const scoreEl = document.getElementById('score');
        const timeEl = document.getElementById('time');
        const restartBtn = document.getElementById('restartBtn');

        let mouse = { x: 50, y: 200, size: 30, speed: 5 };
        let cheese = { x: 500, y: 200, size: 35, currentSize: 35 };
        let obstacles = [];
        let level = 1;
        let score = 0;
        let startTime = Date.now();
        let gameWon = false;
        let keys = {};
        let hitFlash = 0;
        let isHit = false;
        let confetti = [];
        let celebrationActive = false;
        let isEating = false;
        let nibbleFrame = 0;

        function drawMouse(x, y, size) {
            // Body
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.ellipse(x, y, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(x + size * 0.4, y, size * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(x + size * 0.5, y - size * 0.35, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.3, y - size * 0.4, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x + size * 0.55, y - size * 0.1, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(x + size * 0.7, y + size * 0.05, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y);
            ctx.quadraticCurveTo(x - size * 0.8, y - size * 0.3, x - size * 0.9, y + size * 0.2);
            ctx.stroke();

            // Whiskers
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = -1; i <= 1; i++) {
                ctx.beginPath();
                ctx.moveTo(x + size * 0.6, y + size * 0.05);
                ctx.lineTo(x + size * 0.9, y + i * size * 0.15);
                ctx.stroke();
            }
        }

        function drawEatingMouse(x, y, size, frame) {
            // Bobbing animation
            const bob = Math.sin(frame) * 2;
            const mouthOpen = Math.sin(frame * 2) > 0;

            // Body
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.ellipse(x, y + bob, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head (moves forward when nibbling)
            const headOffset = mouthOpen ? 3 : 0;
            ctx.beginPath();
            ctx.arc(x + size * 0.4 + headOffset, y + bob, size * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(x + size * 0.5 + headOffset, y - size * 0.35 + bob, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.3 + headOffset, y - size * 0.4 + bob, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Happy closed eyes (arcs)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + size * 0.55 + headOffset, y - size * 0.1 + bob, size * 0.06, 0, Math.PI);
            ctx.stroke();

            // Nose
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(x + size * 0.7 + headOffset, y + size * 0.05 + bob, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (open/closed for chewing)
            if (mouthOpen) {
                ctx.fillStyle = '#FF6B6B';
                ctx.beginPath();
                ctx.arc(x + size * 0.65 + headOffset, y + size * 0.15 + bob, size * 0.1, 0, Math.PI);
                ctx.fill();
            }

            // Tail (wagging happily)
            const tailWag = Math.sin(frame * 3) * 0.2;
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y + bob);
            ctx.quadraticCurveTo(x - size * 0.8, y - size * 0.3 + Math.sin(frame * 3) * 10, x - size * 0.9, y + size * 0.2 + bob);
            ctx.stroke();

            // Whiskers (twitching)
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = -1; i <= 1; i++) {
                const twitch = Math.sin(frame * 4 + i) * 3;
                ctx.beginPath();
                ctx.moveTo(x + size * 0.6 + headOffset, y + size * 0.05 + bob);
                ctx.lineTo(x + size * 0.9 + headOffset, y + i * size * 0.15 + bob + twitch);
                ctx.stroke();
            }

            // Cheese crumbs flying
            ctx.fillStyle = '#FFD700';
            for (let i = 0; i < 3; i++) {
                const crumbX = x + size * 0.8 + Math.sin(frame + i * 2) * 15;
                const crumbY = y + Math.cos(frame * 2 + i) * 10 - 5;
                const crumbSize = 2 + Math.random();
                ctx.beginPath();
                ctx.arc(crumbX, crumbY + bob, crumbSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawCheese(x, y, size) {
            // Main cheese body
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y + size * 0.3);
            ctx.lineTo(x, y - size * 0.4);
            ctx.lineTo(x + size * 0.5, y + size * 0.3);
            ctx.closePath();
            ctx.fill();

            // Darker side
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(x + size * 0.5, y + size * 0.3);
            ctx.lineTo(x, y - size * 0.4);
            ctx.lineTo(x + size * 0.2, y - size * 0.3);
            ctx.lineTo(x + size * 0.5, y + size * 0.1);
            ctx.closePath();
            ctx.fill();

            // Holes
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.arc(x - size * 0.15, y, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 0.1, y + size * 0.15, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - size * 0.05, y - size * 0.15, size * 0.06, 0, Math.PI * 2);
            ctx.fill();
        }

        let zapperPhase = 0;

        function drawObstacle(obs) {
            const x = obs.x;
            const y = obs.y;
            const w = obs.width;
            const h = obs.height;
            const cx = x + w / 2;
            const cy = y + h / 2;

            // Outer glow
            const glowIntensity = 0.3 + Math.sin(zapperPhase + obs.x) * 0.2;
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 15;

            // Metal frame
            ctx.fillStyle = '#333';
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 6);
            ctx.fill();
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Inner electric area
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.roundRect(x + 4, y + 4, w - 8, h - 8, 4);
            ctx.fill();

            // Electric grid lines (vertical)
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 + glowIntensity})`;
            ctx.lineWidth = 2;
            for (let i = 0.25; i < 1; i += 0.25) {
                ctx.beginPath();
                ctx.moveTo(x + w * i, y + 6);
                ctx.lineTo(x + w * i, y + h - 6);
                ctx.stroke();
            }

            // Electric grid lines (horizontal)
            for (let i = 0.25; i < 1; i += 0.25) {
                ctx.beginPath();
                ctx.moveTo(x + 6, y + h * i);
                ctx.lineTo(x + w - 6, y + h * i);
                ctx.stroke();
            }

            // Spark effects
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            const numSparks = 3;
            for (let i = 0; i < numSparks; i++) {
                const sparkX = x + 10 + Math.sin(zapperPhase * 3 + i * 2 + obs.y) * (w - 20) / 2 + (w - 20) / 2;
                const sparkY = y + 10 + Math.cos(zapperPhase * 2 + i * 3 + obs.x) * (h - 20) / 2 + (h - 20) / 2;

                ctx.beginPath();
                ctx.moveTo(sparkX - 4, sparkY);
                ctx.lineTo(sparkX + 4, sparkY);
                ctx.moveTo(sparkX, sparkY - 4);
                ctx.lineTo(sparkX, sparkY + 4);
                ctx.stroke();
            }

            // Corner bolts
            ctx.fillStyle = '#666';
            const boltSize = 4;
            ctx.beginPath();
            ctx.arc(x + 6, y + 6, boltSize, 0, Math.PI * 2);
            ctx.arc(x + w - 6, y + 6, boltSize, 0, Math.PI * 2);
            ctx.arc(x + 6, y + h - 6, boltSize, 0, Math.PI * 2);
            ctx.arc(x + w - 6, y + h - 6, boltSize, 0, Math.PI * 2);
            ctx.fill();

            // Danger symbol (lightning bolt)
            ctx.fillStyle = `rgba(255, 255, 0, ${0.7 + glowIntensity})`;
            ctx.beginPath();
            ctx.moveTo(cx + 2, cy - h * 0.25);
            ctx.lineTo(cx - 5, cy + 2);
            ctx.lineTo(cx, cy);
            ctx.lineTo(cx - 2, cy + h * 0.25);
            ctx.lineTo(cx + 5, cy - 2);
            ctx.lineTo(cx, cy);
            ctx.closePath();
            ctx.fill();
        }

        function checkObstacleOverlap(obs1, obs2, minGap) {
            return obs1.x - minGap < obs2.x + obs2.width &&
                   obs1.x + obs1.width + minGap > obs2.x &&
                   obs1.y - minGap < obs2.y + obs2.height &&
                   obs1.y + obs1.height + minGap > obs2.y;
        }

        function generateObstacles() {
            obstacles = [];
            const numObstacles = Math.min(level + 1, 8);
            const minGap = 80;

            for (let i = 0; i < numObstacles; i++) {
                let obs;
                let attempts = 0;
                let valid = false;

                do {
                    obs = {
                        x: 120 + Math.random() * (canvas.width - 280),
                        y: Math.random() * (canvas.height - 80),
                        width: 40 + Math.random() * 30,
                        height: 40 + Math.random() * 30,
                        vy: (0.5 + Math.random() * 1) * (Math.random() < 0.5 ? 1 : -1)
                    };

                    valid = !checkCollision(mouse, obs) && !checkCheeseCollision(obs);

                    // Check distance from other obstacles
                    for (const existing of obstacles) {
                        if (checkObstacleOverlap(obs, existing, minGap)) {
                            valid = false;
                            break;
                        }
                    }

                    attempts++;
                } while (attempts < 100 && !valid);

                if (valid) obstacles.push(obs);
            }
        }

        function updateObstacles() {
            for (const obs of obstacles) {
                obs.y += obs.vy;

                // Bounce off top and bottom edges
                if (obs.y <= 0) {
                    obs.y = 0;
                    obs.vy = Math.abs(obs.vy);
                } else if (obs.y + obs.height >= canvas.height) {
                    obs.y = canvas.height - obs.height;
                    obs.vy = -Math.abs(obs.vy);
                }

                // Check if obstacle hits mouse
                if (!isHit && checkCollision(mouse, obs)) {
                    triggerHit();
                }
            }
        }

        let electricSparks = [];

        function triggerHit() {
            isHit = true;
            hitFlash = 1;
            messageEl.textContent = 'ZZZAP! Restarting level...';
            messageEl.style.color = '#00FFFF';

            // Create electric sparks
            electricSparks = [];
            for (let i = 0; i < 20; i++) {
                electricSparks.push({
                    x: mouse.x,
                    y: mouse.y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1
                });
            }

            setTimeout(() => {
                restartLevel();
            }, 1000);
        }

        function restartLevel() {
            mouse.x = 50;
            mouse.y = 200;
            generateObstacles();
            isHit = false;
            hitFlash = 0;
            electricSparks = [];
            messageEl.textContent = '';
        }

        function checkCollision(m, obs) {
            return m.x + m.size * 0.6 > obs.x &&
                   m.x - m.size * 0.6 < obs.x + obs.width &&
                   m.y + m.size * 0.4 > obs.y &&
                   m.y - m.size * 0.4 < obs.y + obs.height;
        }

        function checkCheeseCollision(obs) {
            return cheese.x + cheese.size * 0.5 > obs.x &&
                   cheese.x - cheese.size * 0.5 < obs.x + obs.width &&
                   cheese.y + cheese.size * 0.4 > obs.y &&
                   cheese.y - cheese.size * 0.4 < obs.y + obs.height;
        }

        function checkWin() {
            const dx = mouse.x - cheese.x;
            const dy = mouse.y - cheese.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (mouse.size + cheese.size) * 0.4;
        }

        function spawnConfetti() {
            confetti = [];
            const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
            for (let i = 0; i < 100; i++) {
                confetti.push({
                    x: Math.random() * canvas.width,
                    y: -20 - Math.random() * 200,
                    vx: (Math.random() - 0.5) * 4,
                    vy: 2 + Math.random() * 3,
                    size: 5 + Math.random() * 8,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    shape: Math.random() > 0.5 ? 'rect' : 'circle'
                });
            }
            celebrationActive = true;
        }

        function updateConfetti() {
            for (const c of confetti) {
                c.x += c.vx;
                c.y += c.vy;
                c.rotation += c.rotationSpeed;
                c.vy += 0.05; // gravity
                c.vx *= 0.99; // air resistance
            }
            // Remove confetti that fell off screen
            confetti = confetti.filter(c => c.y < canvas.height + 50);
            if (confetti.length === 0) {
                celebrationActive = false;
            }
        }

        function drawConfetti() {
            for (const c of confetti) {
                ctx.save();
                ctx.translate(c.x, c.y);
                ctx.rotate(c.rotation);
                ctx.fillStyle = c.color;

                if (c.shape === 'rect') {
                    ctx.fillRect(-c.size / 2, -c.size / 4, c.size, c.size / 2);
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, c.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        function nextLevel() {
            level++;
            levelEl.textContent = level;
            score += 100 + level * 10;
            scoreEl.textContent = score;

            mouse.x = 50;
            mouse.y = 200;
            cheese.x = 450 + Math.random() * 100;
            cheese.y = 50 + Math.random() * 300;
            cheese.currentSize = cheese.size;

            generateObstacles();
            gameWon = false;
            isEating = false;
            nibbleFrame = 0;
            celebrationActive = false;
            confetti = [];
            messageEl.textContent = '';
        }

        function resetGame() {
            level = 1;
            score = 0;
            startTime = Date.now();
            mouse = { x: 50, y: 200, size: 30, speed: 5 };
            cheese = { x: 500, y: 200, size: 35, currentSize: 35 };
            levelEl.textContent = level;
            scoreEl.textContent = score;
            messageEl.textContent = '';
            gameWon = false;
            isEating = false;
            nibbleFrame = 0;
            isHit = false;
            hitFlash = 0;
            electricSparks = [];
            celebrationActive = false;
            confetti = [];
            generateObstacles();
        }

        function update() {
            // Update zapper animation
            zapperPhase += 0.1;

            // Decay hit flash and update sparks
            if (hitFlash > 0) {
                hitFlash -= 0.03;

                // Update electric sparks
                for (const spark of electricSparks) {
                    spark.x += spark.vx;
                    spark.y += spark.vy;
                    spark.life -= 0.03;
                    spark.vx *= 0.95;
                    spark.vy *= 0.95;
                }
            }

            // Update confetti
            if (celebrationActive) {
                updateConfetti();
            }

            // Update eating animation
            if (isEating && !gameWon) {
                nibbleFrame += 0.3;
                // Slowly shrink the cheese
                if (cheese.currentSize > 5) {
                    cheese.currentSize -= 0.15;
                }
                // Keep mouse at cheese position
                mouse.x = cheese.x - 20;
                mouse.y = cheese.y;
            }

            if (!gameWon && !isHit && !isEating) {
                updateObstacles();
            }

            if (gameWon || isHit || isEating) return;

            let newX = mouse.x;
            let newY = mouse.y;

            if (keys['ArrowUp'] || keys['KeyW']) newY -= mouse.speed;
            if (keys['ArrowDown'] || keys['KeyS']) newY += mouse.speed;
            if (keys['ArrowLeft'] || keys['KeyA']) newX -= mouse.speed;
            if (keys['ArrowRight'] || keys['KeyD']) newX += mouse.speed;

            // Boundary check
            newX = Math.max(mouse.size, Math.min(canvas.width - mouse.size, newX));
            newY = Math.max(mouse.size * 0.5, Math.min(canvas.height - mouse.size * 0.5, newY));

            // Obstacle collision
            let canMove = true;
            const testMouse = { ...mouse, x: newX, y: newY };
            for (const obs of obstacles) {
                if (checkCollision(testMouse, obs)) {
                    canMove = false;
                    break;
                }
            }

            if (canMove) {
                mouse.x = newX;
                mouse.y = newY;
            }

            if (!isEating && checkWin()) {
                isEating = true;
                messageEl.textContent = 'Nom nom nom... Press SPACE for next level';
                messageEl.style.color = '#2ecc71';
                spawnConfetti();
            }

            // Update time
            timeEl.textContent = Math.floor((Date.now() - startTime) / 1000);
        }

        function draw() {
            // Clear canvas with grid background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            const gridSize = 40;
            ctx.strokeStyle = '#16213e';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw obstacles
            obstacles.forEach(drawObstacle);

            // Draw cheese (use currentSize for eating animation)
            if (cheese.currentSize > 5) {
                drawCheese(cheese.x, cheese.y, cheese.currentSize);
            }

            // Draw mouse (with nibble animation if eating)
            if (isEating) {
                drawEatingMouse(mouse.x, mouse.y, mouse.size, nibbleFrame);
            } else {
                drawMouse(mouse.x, mouse.y, mouse.size);
            }

            // Draw electric shock effect
            if (hitFlash > 0) {
                // Flickering cyan overlay
                const flicker = Math.random() > 0.5 ? 1 : 0.5;
                ctx.fillStyle = `rgba(0, 255, 255, ${hitFlash * 0.3 * flicker})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw lightning bolts from mouse
                ctx.strokeStyle = `rgba(0, 255, 255, ${hitFlash})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 20;

                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.3;
                    let x = mouse.x;
                    let y = mouse.y;
                    const length = 40 + (1 - hitFlash) * 60;

                    ctx.beginPath();
                    ctx.moveTo(x, y);

                    // Jagged lightning path
                    for (let j = 0; j < 5; j++) {
                        const stepLength = length / 5;
                        x += Math.cos(angle) * stepLength + (Math.random() - 0.5) * 15;
                        y += Math.sin(angle) * stepLength + (Math.random() - 0.5) * 15;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                // Draw skeleton effect on mouse (flashing bones)
                if (Math.random() > 0.3) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${hitFlash})`;
                    ctx.lineWidth = 2;
                    // Skeleton body
                    ctx.beginPath();
                    ctx.moveTo(mouse.x - 15, mouse.y);
                    ctx.lineTo(mouse.x + 15, mouse.y);
                    ctx.moveTo(mouse.x, mouse.y - 10);
                    ctx.lineTo(mouse.x, mouse.y + 10);
                    // Skeleton ribs
                    ctx.moveTo(mouse.x - 8, mouse.y - 5);
                    ctx.lineTo(mouse.x + 8, mouse.y - 5);
                    ctx.moveTo(mouse.x - 8, mouse.y + 5);
                    ctx.lineTo(mouse.x + 8, mouse.y + 5);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;

                // Draw electric sparks
                for (const spark of electricSparks) {
                    if (spark.life > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${spark.life})`;
                        ctx.beginPath();
                        ctx.arc(spark.x, spark.y, 3, 0, Math.PI * 2);
                        ctx.fill();

                        // Mini lightning from spark
                        ctx.strokeStyle = `rgba(0, 255, 255, ${spark.life})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(spark.x, spark.y);
                        ctx.lineTo(spark.x + (Math.random() - 0.5) * 10, spark.y + (Math.random() - 0.5) * 10);
                        ctx.stroke();
                    }
                }
            }

            // Draw confetti celebration
            if (celebrationActive) {
                drawConfetti();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && isEating) {
                // Go directly to next level
                nextLevel();
            }
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        restartBtn.addEventListener('click', resetGame);

        // Dialog handling
        const tutorialDialog = document.getElementById('tutorialDialog');
        const aiStatsDialog = document.getElementById('aiStatsDialog');
        const tutorialBtn = document.getElementById('tutorialBtn');
        const aiStatsBtn = document.getElementById('aiStatsBtn');
        const closeTutorial = document.getElementById('closeTutorial');
        const closeAiStats = document.getElementById('closeAiStats');

        tutorialBtn.addEventListener('click', () => {
            tutorialDialog.classList.add('active');
        });

        aiStatsBtn.addEventListener('click', () => {
            aiStatsDialog.classList.add('active');
        });

        closeTutorial.addEventListener('click', () => {
            tutorialDialog.classList.remove('active');
        });

        closeAiStats.addEventListener('click', () => {
            aiStatsDialog.classList.remove('active');
        });

        // Close dialogs on overlay click
        tutorialDialog.addEventListener('click', (e) => {
            if (e.target === tutorialDialog) {
                tutorialDialog.classList.remove('active');
            }
        });

        aiStatsDialog.addEventListener('click', (e) => {
            if (e.target === aiStatsDialog) {
                aiStatsDialog.classList.remove('active');
            }
        });

        // Close dialogs on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                tutorialDialog.classList.remove('active');
                aiStatsDialog.classList.remove('active');
            }
        });

        // Start game
        generateObstacles();
        gameLoop();
    </script>
</body>
</html>
